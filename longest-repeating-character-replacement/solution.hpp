/*
Заведем два указателя. Хотим поддерживать ИНВАРИАНТ "окно между двумя указателями
можно сделать состоящим из 1 буквы". Поддерживаем, сколько раз какая буква встречалась в окне.

Если зафиксировать окно, то ясно, что чтобы проверить ИНВАРИАНТ, нужно взять букву с максимальной частотностью в окне, а остальные попробовать заменить.

Если ИНВАРИАНТ перестал поддерживаться, двигаем окно. В этот момент может нарушиться ИНВАРИАНТ и ещё инвариант. Покажем, что в этом случае и без них всё сработает:
1. max_frequency может стать неактуальным. Мы понижаем frequency у буквы, а это могла быть буква с наибольшей частотностью. 
Чтобы снова обновить result, после того, как мы первый раз нарушили ИНВАРИАНТ,
нужно увеличить max_frequency. В этот момент мы обновим инвариант.
2. На окне не поддерживается ИНВАРИАНТ, даже если сдвинуть левую границу. Но тогда мы
будем двигать левую границу на 1 и правую границу на 1. Ясно, что сильнее сдвигать левую границу
не нужно, т.к. чтобы улучшить результат, нам нужно окно большего размера.
*/

class Solution {
public:
    int characterReplacement(string s, int k) {
        size_t frequency['Z' - 'A' + 1] = {0};

        size_t window_l = 0;
        size_t max_frequency = 0;
        size_t result = 0;
        for(size_t window_r = 0; window_r < s.size(); ++window_r) {
            auto new_frequency = ++frequency[s[window_r] - 'A'];
            max_frequency = std::max(max_frequency, new_frequency);

            auto substring_size = window_r - window_l + 1;
            if (substring_size > k + max_frequency) {
                --frequency[s[window_l] - 'A'];
                ++window_l;
            }
            else {
                result = std::max(result, substring_size);
            }
        }
        return result;
    }
};

